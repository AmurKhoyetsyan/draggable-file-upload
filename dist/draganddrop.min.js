/***********************************************************************
 * 
 * Copyright (c) 2020 Amur Khoyetsyan
 * 
 * The MIT License (MIT)
 * 
 * When we bring the file closer to the installation area
 * a new class is added to the installation section called "dragover",
 * with which we can shape the installation areaâ€¤
 * 
 ************************************************************************/

let Chunk={},params={chunkSize:1e6,url:null,file:null,uniqueID:!0,uniqueIDLen:10,keys:{key:"file",end:"end",order:"order"},form:[],headers:{"Content-type":"multipart/form-data"}};Chunk.params=params;const setParams=e=>{for(let t in e)Chunk.params[t]=e[t]},generateUniqueID=(e=10,t="")=>(t+=Math.random().toString(36).substr(2,9)).length>e?t.substr(0,e):t.length===e?t:generateUniqueID(e,t),fileUploader=e=>{console.log(e);let t=new XMLHttpRequest,n=Chunk.params.headers;t.open("POST",Chunk.params.url);for(let e in n)t.setRequestHeader(e,n[e]);t.send(e[0]),t.loaded=(t=>{e.shift(),e.length>0&&fileUploader(e)}),t.onerror=(e=>new TypeError(e))},createChunk=(e,t,n=0,r=1,l=[])=>{let d=Chunk.params,a=Math.min(n+d.chunkSize,e.size),i=e.slice(n,a),s=new FormData,o=t===r;if(s.append(d.keys.key,i),s.append(d.keys.order,r),s.append(d.keys.end,o),d.form.forEach(e=>{s.append(e.key,e.value)}),l.push(s),!o)return createChunk(e,t,o,++r,l);fileUploader(l,s,a)};Chunk.uploader=(e=>{setParams(e);let t=e.file;if(null===t)return new TypeError("Change File");{let e=Math.ceil(t.size/Chunk.params.chunkSize);Chunk.params.uniqueID&&Chunk.params.form.push({key:"uuid",value:generateUniqueID(Chunk.params.uniqueIDLen)}),createChunk(t,e,0)}});let DAD={name:"Drag And Drop",elem:{file:[],drag:[],draggable:[]},file:null,data:{name:"Drag And Drop",files:[]}},defaultProps={element:null,input:null,start:void 0,end:void 0};const isEmpty=(e,t)=>{if(Array.isArray(e))return 0===e.length&&(t(new Error("Not a File")),!0);try{return 0===Object.keys(e).length&&(t(new Error("Not a File")),!0)}catch(e){t(new TypeError("Is not a array or object"))}return!1},addClass=(e,t)=>{null!==t&&null!==DAD.elem.drag?DAD.elem.drag.forEach(e=>{if(e.elem===t)return!e.elem.classList.contains("dragover")&&e.elem.classList.add("dragover"),!0}):null!==DAD.elem.drag&&DAD.elem.drag.forEach(t=>{if(t.elem===e.target)return!t.elem.classList.contains("dragover")&&t.elem.classList.add("dragover"),!0})},removeClass=e=>{null!==DAD.elem.drag&&DAD.elem.drag.forEach(e=>{e.elem.classList.contains("dragover")&&e.elem.classList.remove("dragover")})},dragenter=(e,t=null)=>{e.preventDefault(),addClass(e,t)},dragleave=e=>{e.preventDefault(),removeClass()},dragover=(e,t=null)=>{e.preventDefault(),addClass(e,t)},getElemName=e=>{let t={};return t.id=e.hasAttribute("id")?e.getAttribute("id"):null,t.name=e.hasAttribute("name")?e.getAttribute("name"):null,t.classes=e.hasAttribute("class")?e.getAttribute("class"):null,t.tagName=e.nodeName,t.node=e,t};function FileListItem(e){for(var t,n=t=(e=[].slice.call(Array.isArray(e)?e:arguments)).length,r=!0;n--&&r;)r=e[n]instanceof File;if(!r)throw new TypeError("expected argument to FileList is File or array of File objects");for(n=new ClipboardEvent("").clipboardData||new DataTransfer;t--;)n.items.add(e[t]);return n.files}const getIndex=(e,t)=>{let n=0;if("drop"===t){n=DAD.elem.drag.length;for(let t=0;t<n;t++)if(DAD.elem.drag[t].elem===e)return{index:t,type:"drop"}}else{n=DAD.elem.file.length;for(let t=0;t<n;t++)if(DAD.elem.file[t].elem===e)return{index:t,type:"file"}}return{index:-1,type:""}},addFile=(e,t,n)=>{let r=getIndex(t,n);if(-1!==r.index&&("drop"===r.type?void 0!==DAD.elem.drag[r.index].start&&DAD.elem.drag[r.index].start():void 0!==DAD.elem.file[r.index].start&&DAD.elem.file[r.index].start()),DAD.file=[],DAD.data.files=[],removeClass(),DAD.file="drop"===n?e.dataTransfer.files:e.target.files,isEmpty(DAD.file,e=>{-1!==r.index&&("drop"===r.type?void 0!==DAD.elem.drag[r.index].end&&DAD.elem.drag[r.index].end(null,e):void 0!==DAD.elem.file[r.index].end&&DAD.elem.file[r.index].end(null,e))}))return!1;let l=getTypeMultiple(t);return void 0!==DAD.file&&previewFile(DAD.file,n,getElemName(t),l).then(e=>{-1!==r.index&&("drop"===r.type?(null!==DAD.elem.drag[r.index].input&&(DAD.elem.drag[r.index].input.files=new FileListItem(l?[...DAD.file]:DAD.file[0])),void 0!==DAD.elem.drag[r.index].end&&DAD.elem.drag[r.index].end(e,null)):(null!==DAD.elem.file[r.index].input&&(DAD.elem.file[r.index].input.files=new FileListItem(l?[...DAD.file]:DAD.file[0])),void 0!==DAD.elem.file[r.index].end&&DAD.elem.file[r.index].end(e,null)))}).catch(e=>{-1!==r.index&&("drop"===r.type?void 0!==DAD.elem.drag[r.index].end&&DAD.elem.drag[r.index].end(null,e):void 0!==DAD.elem.file[r.index].end&&DAD.elem.file[r.index].end(null,e))}),!0},previewFile=(e,t,n,r,l=0)=>{let d=new FileReader;d.readAsDataURL(e[l]);let a=(webkitURL||URL).createObjectURL(e[l]);return new Promise((i,s)=>{d.onloadend=(s=>{DAD.data.files.push({file:e[l],blob:a,data:d.result,filename:e[l].name,type:t,inputName:n,total:s.total,loaded:s.loaded}),r?(l++,e.length>l?i(previewFile(DAD.file,t,n,r,l)):i(DAD.data)):i(DAD.data)}),d.onerror=(e=>{s(new Error("Failed to load ",e))})})},isNodelist=e=>void 0!==e.length&&void 0!==e.item,toBoolean=e=>"true"===e,getTypeMultiple=e=>{let t=!1;return e.hasAttribute("multiple")&&e.getAttribute("multiple").length>0&&(t=toBoolean(e.getAttribute("multiple"))),t},getAllTabsByParent=e=>{let t=e.getElementsByTagName("*");for(let n of t)n.addEventListener("dragenter",t=>dragenter(t,e),!1),n.addEventListener("dragover",t=>dragover(t,e),!1)},elemAddEventDragged=e=>{getAllTabsByParent(e),e.addEventListener("dragenter",dragenter,!1),e.addEventListener("dragleave",dragleave,!1),e.addEventListener("dragover",dragover,!1),e.addEventListener("drop",t=>{t.preventDefault(),addFile(t,e,"drop")},!1)};DAD.draggedUpload=((e=defaultProps)=>{let t=e.element;if(null!==t&&isNodelist(t))for(let n of t)DAD.elem.drag.push({elem:n,input:e.input?e.input:null,start:e.start?e.start:void 0,end:e.end?e.end:void 0}),elemAddEventDragged(n);else null!==t&&(DAD.elem.drag.push({elem:t,input:e.input?e.input:null,start:e.start?e.start:void 0,end:e.end?e.end:void 0}),elemAddEventDragged(t))}),DAD.fileChange=((e=defaultProps)=>{let t=e.element;if(null!==t&&isNodelist(t))for(let n of t)DAD.elem.file.push({elem:n,input:e.input?e.input:null,start:e.start?e.start:void 0,end:e.end?e.end:void 0}),n.addEventListener("change",e=>{e.preventDefault(),addFile(e,n,"change")},!1);else null!==t&&(DAD.elem.file.push({elem:t,input:e.input?e.input:null,start:e.start?e.start:void 0,end:e.end?e.end:void 0}),t.addEventListener("change",e=>{e.preventDefault(),addFile(e,t,"change")},!1))});const dragContext=e=>{DAD.elem.draggable.forEach(t=>{if(e.target===t.node){let n=0,r=0;n=t.cords.startX-e.pageX,r=t.cords.startY-e.pageY,t.cords.endX+=-n,t.cords.endY+=-r,t.cords.startX=e.pageX,t.cords.startY=e.pageY,t.node.style.zIndex="100",t.node.style.top=`${t.cords.endY}px`,t.node.style.left=`${t.cords.endX}px`}else t.node.style.zIndex="99"})},addInObject=e=>{e.style.position="fixed",e.style.zIndex="99",e.style.cursor="move",DAD.elem.draggable.push({node:e,cords:{startX:0,startY:0,endX:0,endY:0}})},addEventDragAndDrop=()=>{DAD.elem.draggable.forEach(e=>{e.node.addEventListener("mousedown",t=>{let{x:n,y:r}=e.node.getBoundingClientRect();e.cords.startX=t.pageX,e.cords.startY=t.pageY,e.cords.endX=n,e.cords.endY=r,e.node.addEventListener("mousemove",dragContext,!1)}),e.node.addEventListener("mouseup",t=>{e.node.removeEventListener("mousemove",dragContext,!1)},!1)})};DAD.draggableContext=(e=>{if(null!==e&&isNodelist(e))for(let t of e)addInObject(t);else null!==e&&addInObject(e);null!==e&&DAD.elem.draggable.forEach(e=>{e.node.addEventListener("mousedown",t=>{let{x:n,y:r}=e.node.getBoundingClientRect();e.cords.startX=t.pageX,e.cords.startY=t.pageY,e.cords.endX=n,e.cords.endY=r,e.node.addEventListener("mousemove",dragContext,!1)}),e.node.addEventListener("mouseup",t=>{e.node.removeEventListener("mousemove",dragContext,!1)},!1)})});
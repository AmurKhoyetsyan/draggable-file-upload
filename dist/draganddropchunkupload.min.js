/***********************************************************************
 * 
 * Copyright (c) 2020 Amur Khoyetsyan
 * 
 * The MIT License (MIT)
 * 
 * When we bring the file closer to the installation area
 * a new class is added to the installation section called "dragover",
 * with which we can shape the installation areaâ€¤
 * 
 ************************************************************************/

let Chunk={name:"Chunk Uploader",file:{},inProcess:null,completed:function(){return{chunks:100*(this.file.numberOfChunk-this.inProcess)/this.file.numberOfChunk,one:100/this.file.numberOfChunk}}},params={chunkSize:1e6,url:null,file:null,uniqueID:!1,keys:{key:"file",end:"end",order:"order"},form:{},headers:{"Content-type":"multipart/form-data"},start:null,end:null,onError:null,progress:null};Chunk.params=params;const setParams=e=>{for(let r in e)Chunk.params[r]=e[r]},generateUniqueID=(e=10,r="")=>(r+=Math.random().toString(36).substr(2,9)).length>e?r.substr(0,e):r.length===e?r:generateUniqueID(e,r),updateProgress=e=>{if(e.lengthComputable){let r=Math.round(e.loaded/e.total*100),n=Chunk.completed(),t=n.chunks+n.one*r/100;null!==Chunk.params.progress&&Chunk.params.progress(t)}},fileUploader=e=>{let r=new XMLHttpRequest,n=Chunk.params.headers;r.upload.addEventListener("progress",updateProgress),r.open("POST",Chunk.params.url);for(let e in n)r.setRequestHeader(e,n[e]);return new Promise((n,t)=>{r.send(e[0]),r.onload=(r=>{n({chunks:e,event:r.currentTarget})}),r.onerror=(e=>{t(e)})})},uploadChunks=e=>{fileUploader(e).then(e=>{if(e.chunks.shift(),Chunk.inProcess=e.chunks.length,e.chunks.length>0)uploadChunks(e.chunks);else if(null!==Chunk.params.end){let r=e.event;try{Chunk.params.end({response:JSON.parse(r.response),statusText:r.statusText,status:r.status})}catch(e){Chunk.params.onError(e)}}}).catch(e=>{null!==Chunk.params.onError&&Chunk.params.onError(e)})},getChunks=(e,r=1e6,n=0,t=1,a=[])=>{let l=Math.min(n+r,e.size),d=e.slice(n,l),s=Math.ceil(e.size/r)===t;return a.push(d),s?a:getChunks(e,r,l,++t,a)},createChunk=e=>{let r=Chunk.params,n=r.form,t=getChunks(e,r.chunkSize),a=0,l=t.map((e,t)=>{let l=new FormData;a=t+1,l.append(r.keys.key,e),l.append(r.keys.order,a),l.append(r.keys.end,Chunk.file.numberOfChunk===a);for(let e in n)l.append(e,n[e]);return l});Chunk.inProcess=a,uploadChunks(l)};Chunk.getChunks=getChunks,Chunk.uploader=(e=>{setParams(e);let r=e.file;if(null!==r)try{null!==Chunk.params.start&&Chunk.params.start(),Chunk.file.fileSize=r.size,Chunk.file.numberOfChunk=Math.ceil(r.size/Chunk.params.chunkSize),Chunk.params.uniqueID&&(Chunk.params.form.uuid=generateUniqueID(Chunk.params.uniqueID)),createChunk(r)}catch(e){null!==Chunk.params.onError&&Chunk.params.onError(e)}else null!==Chunk.params.onError&&Chunk.params.onError(new TypeError("Change File"))});let DAD={name:"Drag And Drop",elem:{file:[],drag:[],draggable:[]},file:null,data:{name:"Drag And Drop",files:[]}},defaultProps={element:null,input:null,start:void 0,end:void 0};const isEmpty=(e,r)=>{if(Array.isArray(e))return 0===e.length&&(r(new Error("Not a File")),!0);try{return 0===Object.keys(e).length&&(r(new Error("Not a File")),!0)}catch(e){r(new TypeError("Is not a array or object"))}return!1},addClass=(e,r)=>{null!==r&&null!==DAD.elem.drag?DAD.elem.drag.forEach((e,n)=>{if(e.elem===r)return 1===DAD.elem.drag[n].dragover&&(DAD.elem.drag[n].dragover=2,DAD.elem.drag[n].dragenter(e.elem,n)),!e.elem.classList.contains("dragover")&&e.elem.classList.add("dragover"),!0}):null!==DAD.elem.drag&&DAD.elem.drag.forEach((r,n)=>{if(r.elem===e.target)return 1===DAD.elem.drag[n].dragover&&(DAD.elem.drag[n].dragover=2,DAD.elem.drag[n].dragleave(r.elem,n)),!r.elem.classList.contains("dragover")&&r.elem.classList.add("dragover"),!0})},removeClass=e=>{null!==DAD.elem.drag&&DAD.elem.drag.forEach((e,r)=>(2===DAD.elem.drag[r].dragover&&(DAD.elem.drag[r].dragover=1,DAD.elem.drag[r].dragleave(e.elem,r)),e.elem.classList.contains("dragover")&&e.elem.classList.remove("dragover"),!0))},dragenter=(e,r=null)=>{e.preventDefault(),addClass(e,r)},dragleave=e=>{e.preventDefault(),removeClass()},dragover=(e,r=null)=>{e.preventDefault(),addClass(e,r)},getElemName=e=>{let r={};return r.id=e.hasAttribute("id")?e.getAttribute("id"):null,r.name=e.hasAttribute("name")?e.getAttribute("name"):null,r.classes=e.hasAttribute("class")?e.getAttribute("class"):null,r.tagName=e.nodeName,r.node=e,r};function FileListItem(e){for(var r,n=r=(e=[].slice.call(Array.isArray(e)?e:arguments)).length,t=!0;n--&&t;)t=e[n]instanceof File;if(!t)throw new TypeError("expected argument to FileList is File or array of File objects");for(n=new ClipboardEvent("").clipboardData||new DataTransfer;r--;)n.items.add(e[r]);return n.files}const getIndex=(e,r)=>{let n=0;if("drop"===r){n=DAD.elem.drag.length;for(let r=0;r<n;r++)if(DAD.elem.drag[r].elem===e)return{index:r,type:"drop"}}else{n=DAD.elem.file.length;for(let r=0;r<n;r++)if(DAD.elem.file[r].elem===e)return{index:r,type:"file"}}return{index:-1,type:""}},addFile=(e,r,n)=>{let t=getIndex(r,n);if(-1!==t.index&&("drop"===t.type?(2===DAD.elem.drag[t.index].dragover&&(DAD.elem.drag[t.index].dragover=1,DAD.elem.drag[t.index].dragleave(r,t.index)),void 0!==DAD.elem.drag[t.index].start&&DAD.elem.drag[t.index].start()):void 0!==DAD.elem.file[t.index].start&&DAD.elem.file[t.index].start()),DAD.file=[],DAD.data.files=[],removeClass(),DAD.file="drop"===n?e.dataTransfer.files:e.target.files,isEmpty(DAD.file,e=>{-1!==t.index&&("drop"===t.type?void 0!==DAD.elem.drag[t.index].end&&DAD.elem.drag[t.index].end(null,e):void 0!==DAD.elem.file[t.index].end&&DAD.elem.file[t.index].end(null,e))}))return!1;let a=getTypeMultiple(r);return void 0!==DAD.file&&previewFile(DAD.file,n,getElemName(r),a).then(e=>{-1!==t.index&&("drop"===t.type?(null!==DAD.elem.drag[t.index].input&&(DAD.elem.drag[t.index].input.files=new FileListItem(a?[...DAD.file]:DAD.file[0])),void 0!==DAD.elem.drag[t.index].end&&DAD.elem.drag[t.index].end(e,null)):(null!==DAD.elem.file[t.index].input&&(DAD.elem.file[t.index].input.files=new FileListItem(a?[...DAD.file]:DAD.file[0])),void 0!==DAD.elem.file[t.index].end&&DAD.elem.file[t.index].end(e,null)))}).catch(e=>{-1!==t.index&&("drop"===t.type?void 0!==DAD.elem.drag[t.index].end&&DAD.elem.drag[t.index].end(null,e):void 0!==DAD.elem.file[t.index].end&&DAD.elem.file[t.index].end(null,e))}),!0},previewFile=(e,r,n,t,a=0)=>{let l=new FileReader;l.readAsDataURL(e[a]);let d=(webkitURL||URL).createObjectURL(e[a]);return new Promise((s,i)=>{l.onloadend=(i=>{DAD.data.files.push({file:e[a],blob:d,data:l.result,filename:e[a].name,type:r,inputName:n,total:i.total,loaded:i.loaded}),t?(a++,e.length>a?s(previewFile(DAD.file,r,n,t,a)):s(DAD.data)):s(DAD.data)}),l.onerror=(e=>{i(new Error("Failed to load ",e))})})},isNodeList=e=>void 0!==e.length&&void 0!==e.item,toBoolean=e=>"true"===e,getTypeMultiple=e=>{let r=!1;return e.hasAttribute("multiple")&&e.getAttribute("multiple").length>0&&(r=toBoolean(e.getAttribute("multiple"))),r},getAllTabsByParent=e=>{let r=e.getElementsByTagName("*");for(let n of r)n.addEventListener("dragenter",r=>dragenter(r,e),!1),n.addEventListener("dragover",r=>dragover(r,e),!1);e.addEventListener("dragenter",r=>dragenter(r,e),!1),e.addEventListener("dragover",r=>dragover(r,e),!1)},elemAddEventDragged=e=>{getAllTabsByParent(e),e.addEventListener("dragenter",dragenter,!1),e.addEventListener("dragleave",dragleave,!1),e.addEventListener("dragover",dragover,!1),e.addEventListener("drop",r=>{r.preventDefault(),addFile(r,e,"drop")},!1)};DAD.draggedUpload=((e=defaultProps)=>{let r=e.element;if(null!==r&&isNodeList(r))for(let n of r)DAD.elem.drag.push({elem:n,input:e.input?e.input:null,dragenter:e.dragenter?e.dragenter:void 0,dragleave:e.dragleave?e.dragleave:void 0,dragover:e.dragenter&&e.dragleave?1:0,start:e.start?e.start:void 0,end:e.end?e.end:void 0}),elemAddEventDragged(n);else null!==r&&(DAD.elem.drag.push({elem:r,input:e.input?e.input:null,dragenter:e.dragenter?e.dragenter:void 0,dragleave:e.dragleave?e.dragleave:void 0,dragover:e.dragenter&&e.dragleave?1:0,start:e.start?e.start:void 0,end:e.end?e.end:void 0}),elemAddEventDragged(r))}),DAD.fileChange=((e=defaultProps)=>{let r=e.element;if(null!==r&&isNodeList(r))for(let n of r)DAD.elem.file.push({elem:n,input:e.input?e.input:null,start:e.start?e.start:void 0,end:e.end?e.end:void 0}),n.addEventListener("change",e=>{e.preventDefault(),addFile(e,n,"change")},!1);else null!==r&&(DAD.elem.file.push({elem:r,input:e.input?e.input:null,start:e.start?e.start:void 0,end:e.end?e.end:void 0}),r.addEventListener("change",e=>{e.preventDefault(),addFile(e,r,"change")},!1))});const dragContext=e=>{DAD.elem.draggable.forEach(r=>{if(e.target===r.node){let n=0,t=0;n=r.cords.startX-e.pageX,t=r.cords.startY-e.pageY,r.cords.endX+=-n,r.cords.endY+=-t,r.cords.startX=e.pageX,r.cords.startY=e.pageY,r.node.style.zIndex="100",r.node.style.top=`${r.cords.endY}px`,r.node.style.left=`${r.cords.endX}px`}else r.node.style.zIndex="99"})},addInObject=e=>{e.style.position="fixed",e.style.zIndex="99",e.style.cursor="move",DAD.elem.draggable.push({node:e,cords:{startX:0,startY:0,endX:0,endY:0}})},addEventDragAndDrop=()=>{DAD.elem.draggable.forEach(e=>{e.node.addEventListener("mousedown",r=>{let{x:n,y:t}=e.node.getBoundingClientRect();e.cords.startX=r.pageX,e.cords.startY=r.pageY,e.cords.endX=n,e.cords.endY=t,e.node.addEventListener("mousemove",dragContext,!1)}),e.node.addEventListener("mouseup",r=>{e.node.removeEventListener("mousemove",dragContext,!1)},!1)})};DAD.draggableContext=(e=>{if(null!==e&&isNodeList(e))for(let r of e)addInObject(r);else null!==e&&addInObject(e);null!==e&&DAD.elem.draggable.forEach(e=>{e.node.addEventListener("mousedown",r=>{let{x:n,y:t}=e.node.getBoundingClientRect();e.cords.startX=r.pageX,e.cords.startY=r.pageY,e.cords.endX=n,e.cords.endY=t,e.node.addEventListener("mousemove",dragContext,!1)}),e.node.addEventListener("mouseup",r=>{e.node.removeEventListener("mousemove",dragContext,!1)},!1)})});